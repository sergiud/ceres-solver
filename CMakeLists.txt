# Ceres Solver - A fast non-linear least squares minimizer
# Copyright 2023 Google Inc. All rights reserved.
# http://ceres-solver.org/
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * Neither the name of Google Inc. nor the names of its contributors may be
#   used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Authors: keir@google.com (Keir Mierle)
#          alexs.mac@gmail.com (Alex Stewart)

cmake_minimum_required(VERSION 3.16...3.27)

# On macOS, add the Homebrew prefix (with appropriate suffixes) to the
# respective HINTS directories (after any user-specified locations).  This
# handles Homebrew installations into non-standard locations (not /usr/local).
# We do not use CMAKE_PREFIX_PATH for this as given the search ordering of
# find_xxx(), doing so would override any user-specified HINTS locations with
# the Homebrew version if it exists.
if (CMAKE_SYSTEM_NAME MATCHES "Darwin")
  find_program(HOMEBREW_EXECUTABLE brew)
  mark_as_advanced(FORCE HOMEBREW_EXECUTABLE)
  if (HOMEBREW_EXECUTABLE)
    # Detected a Homebrew install, query for its install prefix.
    execute_process(COMMAND ${HOMEBREW_EXECUTABLE} --prefix
      OUTPUT_VARIABLE HOMEBREW_INSTALL_PREFIX
      OUTPUT_STRIP_TRAILING_WHITESPACE)
    message(STATUS "Detected Homebrew with install prefix: "
      "${HOMEBREW_INSTALL_PREFIX}, adding to CMake search paths.")
    list(APPEND CMAKE_PREFIX_PATH "${HOMEBREW_INSTALL_PREFIX}")
  endif()
endif()

project (Ceres
  LANGUAGES C CXX
  DESCRIPTION "A Large Scale Non-linear Optimization Library"
)

# NOTE: The following CMake variables must be applied consistently to all
# targets in project to avoid visibility warnings by placing the variables at
# the project top.

# Always build position-independent code (PIC), even when building Ceres as a
# static library so that shared libraries can link against it, not just
# executables (PIC does not apply on Windows). Global variable can be overridden
# by the user whereas target properties can be not.
set(CMAKE_POSITION_INDEPENDENT_CODE ON)
# Set the default symbol visibility to hidden to unify the behavior among
# the various compilers and to get smaller binaries
set(CMAKE_C_VISIBILITY_PRESET hidden)
set(CMAKE_CXX_VISIBILITY_PRESET hidden)
set(CMAKE_VISIBILITY_INLINES_HIDDEN ON)

# NOTE: The 'generic' CMake variables CMAKE_[SOURCE/BINARY]_DIR should not be
#       used.  Always use the project-specific variants (generated by CMake):
#       <PROJECT_NAME_MATCHING_CASE>_[SOURCE/BINARY]_DIR, e.g.
#       Ceres_SOURCE_DIR (note, *not* CERES_SOURCE_DIR) instead, as these will
#       always point to the correct directories for the Ceres project, even if
#       it is nested inside another source tree, whereas the 'generic'
#       CMake variables refer to the *first* project() declaration, i.e. the
#       top-level project, not Ceres, if Ceres is nested.

# Make CMake aware of the cmake folder for local FindXXX scripts,
# append rather than set in case the user has passed their own
# additional paths via -D.
list(APPEND CMAKE_MODULE_PATH "${Ceres_SOURCE_DIR}/cmake")

include(AddCompileFlagsIfSupported)
include(AddGerritCommitHook)
include(CeresCompileOptionsToComponents)
include(CheckCXXCompilerFlag)
include(CheckLanguage)
include(CheckLibraryExists)
include(CMakeDependentOption)
include(CMakePackageConfigHelpers)
include(CreateCeresConfig)
include(DetectBrokenStackCheckMacOSXcodePairing)
include(EnableSanitizer)
include(FeatureSummary)
include(GenerateExportHeader)
include(GNUInstallDirs)
include(PrettyPrintCMakeList)
include(ReadCeresVersionFromSource)
include(UpdateCacheVariable)

check_cxx_compiler_flag(/bigobj HAVE_BIGOBJ)
check_library_exists(m pow "" HAVE_LIBM)

# Xcode 11.0-1 with macOS 10.15 (Catalina) broke alignment.
detect_broken_stack_check_macos_xcode_pairing()
# Set up the git hook to make Gerrit Change-Id: lines in commit messages.
add_gerrit_commit_hook(${Ceres_SOURCE_DIR} ${Ceres_BINARY_DIR})

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${Ceres_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${Ceres_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${Ceres_BINARY_DIR}/lib)
# Set postfixes for generated libraries based on buildtype.
set(CMAKE_RELEASE_POSTFIX "")
set(CMAKE_DEBUG_POSTFIX "-debug")

# Read the Ceres version from the source, such that we only ever have a single
# definition of the Ceres version.
read_ceres_version_from_source(${Ceres_SOURCE_DIR})

option (BUILD_BENCHMARKS "Build Ceres benchmarking suite" ON)
option (BUILD_DOCUMENTATION "Build User's Guide (html)" OFF)
option (BUILD_EXAMPLES "Build examples" ON)
option (BUILD_SHARED_LIBS "Build Ceres as a shared library." OFF)
option (BUILD_TESTING "Enable tests" ON)

option (WITH_CUDA "Enable use of CUDA linear algebra solvers." ON)
option (WITH_CUSTOM_BLAS
       "Use handcoded BLAS routines (usually faster) instead of Eigen."
       ON)
# Enable the use of Eigen as a sparse linear algebra library for
# solving the nonlinear least squares problems.
option (WITH_EIGENSPARSE "Enable Eigen as a sparse linear algebra library." ON)
option (WITH_LAPACK "Enable use of LAPACK directly within Ceres." ON)
option (WITH_MINIGLOG "Use a stripped down version of glog." OFF)
# Template specializations for the Schur complement based solvers. If
# compile time, binary size or compiler performance is an issue, you
# may consider disabling this.
option (WITH_SCHUR_SPECIALIZATIONS "Enable fixed-size schur specializations." ON)
option (WITH_SUITESPARSE "Enable SuiteSparse." ON)
option (WITH_UNINSTALL_TARGET "Add a custom target to ease removal of installed targets" ON)

cmake_dependent_option (WITH_ACCELERATESPARSE
  "Enable use of sparse solvers in Apple's Accelerate framework." ON
  APPLE OFF
)
cmake_dependent_option (WITH_BITCODE
  "Enable bitcode for iOS builds (disables inline optimizations for Eigen)." OFF
  APPLE OFF
)
cmake_dependent_option (WITH_EIGENMETIS "Enable Eigen METIS support." ON
  WITH_EIGENSPARSE OFF
)
set (WITH_SANITIZERS "" CACHE STRING
  "Semicolon-separated list of sanitizers to use (e.g address, memory, thread)")

enable_sanitizer (${WITH_SANITIZERS})

if (BUILD_TESTING)
  enable_testing ()
endif (BUILD_TESTING)


if (ANDROID)
  option(WITH_STRIPPED_DEBUG_SYMBOLS "Strip debug symbols from Android builds (reduces file sizes)" ON)
endif()

# IOS is defined iff using the iOS.cmake CMake toolchain to build a static
# library for iOS.
if (IOS)
  message(STATUS "Building Ceres for iOS platform: ${IOS_PLATFORM}")

  # Ceres requires at least iOS 7.0+.
  if (IOS_DEPLOYMENT_TARGET VERSION_LESS 7.0)
    message(FATAL_ERROR "Unsupported iOS version: ${IOS_DEPLOYMENT_TARGET}, Ceres "
      "requires at least iOS version 7.0")
  endif()

  update_cache_variable(WITH_MINIGLOG ON)
  message(STATUS "Building for iOS: Forcing use of miniglog instead of glog.")

  # Apple claims that the BLAS call dsyrk_ is a private API, and will not allow
  # you to submit to the Apple Store if the symbol is present.
  update_cache_variable(WITH_LAPACK OFF)
  message(STATUS "Building for iOS: SuiteSparse, WITH_LAPACK, gflags "
    "are not available.")

  update_cache_variable(BUILD_EXAMPLES OFF)
  message(STATUS "Building for iOS: Will not build examples.")
endif (IOS)

unset(CERES_COMPILE_OPTIONS)

if (CMAKE_VERSION VERSION_LESS 3.17)
  set (CUDAPackage CUDA)
else (CMAKE_VERSION VERSION_LESS 3.17)
  set (CUDAPackage CUDAToolkit)
endif (CMAKE_VERSION VERSION_LESS 3.17)

if (WITH_CUDA)
  check_language (CUDA)
else (WITH_CUDA)
  set (CMAKE_DISABLE_FIND_PACKAGE_${CUDAPackage} ON)
endif (WITH_CUDA)

if (NOT WITH_ACCELERATESPARSE)
  set (CMAKE_DISABLE_FIND_PACKAGE_AccelerateSparse ON)
endif (NOT WITH_ACCELERATESPARSE)

if (NOT BUILD_BENCHMARKS)
  set (CMAKE_DISABLE_FIND_PACKAGE_benchmark ON)
endif (NOT BUILD_BENCHMARKS)

if (NOT BUILD_DOCUMENTATION)
  set (CMAKE_DISABLE_FIND_PACKAGE_Sphinx ON)
endif (NOT BUILD_DOCUMENTATION)

if (NOT WITH_EIGENMETIS)
  set (CMAKE_DISABLE_FIND_PACKAGE_METIS ON)
endif (NOT WITH_EIGENMETIS)

if (NOT WITH_LAPACK)
  set (CMAKE_DISABLE_FIND_PACKAGE_LAPACK ON)
endif (NOT WITH_LAPACK)

if (NOT WITH_SUITESPARSE)
  set (CMAKE_DISABLE_FIND_PACKAGE_SuiteSparse ON)
endif (NOT WITH_SUITESPARSE)

find_package (AccelerateSparse)
# Version 1.3 was first to provide import targets
find_package (benchmark 1.3 NO_MODULE)
# Eigen delivers Eigen3Config.cmake since v3.3.3
find_package (Eigen3 3.3.4 REQUIRED NO_MODULE)
find_package (gflags 2.2.0 NO_MODULE)
find_package (Glog)
find_package (LAPACK)
find_package (METIS)
find_package (Sphinx COMPONENTS sphinx_rtd_theme)
find_package (SuiteSparse 4.5.6 COMPONENTS CHOLMOD SPQR OPTIONAL_COMPONENTS Partition)
find_package (Threads REQUIRED)

# On older versions of CMake (20.04 default is 3.16) FindCUDAToolkit was
# not available, but FindCUDA was deprecated. To avoid special-case handling
# elsewhere, emulate the effects of FindCUDAToolkit locally in terms of the
# expected CMake imported targets and defined variables. This can be removed
# from as soon as the min CMake version is >= 3.17.
find_package (${CUDAPackage})

if (WITH_EIGENSPARSE)
  list (APPEND CERES_COMPILE_OPTIONS CERES_USE_EIGEN_SPARSE)
else (WITH_EIGENSPARSE)
  add_definitions (-DEIGEN_MPL2_ONLY)
endif (WITH_EIGENSPARSE)

if (NOT LAPACK_FOUND)
  list (APPEND CERES_COMPILE_OPTIONS CERES_NO_LAPACK)
endif (NOT LAPACK_FOUND)

if (${CUDAPackage}_FOUND)
  enable_language (CUDA)
endif (${CUDAPackage}_FOUND)

if (CUDA_FOUND)
  message(STATUS "Found CUDA version ${CUDA_VERSION} installed in: "
    "${CUDA_TOOLKIT_ROOT_DIR} via legacy (< 3.17) CMake module. "
    "Using the legacy CMake module means that any installation of "
    "Ceres will require that the CUDA libraries be installed in a "
    "location included in the LD_LIBRARY_PATH.")

  macro(DECLARE_IMPORTED_CUDA_TARGET COMPONENT)
    add_library(CUDA::${COMPONENT} INTERFACE IMPORTED)
    target_include_directories(
      CUDA::${COMPONENT} INTERFACE ${CUDA_INCLUDE_DIRS})
    target_link_libraries(
      CUDA::${COMPONENT} INTERFACE ${CUDA_${COMPONENT}_LIBRARY} ${ARGN})
  endmacro()

  declare_imported_cuda_target(cublas)
  declare_imported_cuda_target(cusolver)
  declare_imported_cuda_target(cusparse)
  declare_imported_cuda_target(cudart ${CUDA_LIBRARIES})

  set(CUDAToolkit_BIN_DIR ${CUDA_TOOLKIT_ROOT_DIR}/bin)
elseif (CUDAToolkit_FOUND)
  set(CUDAToolkit_DEPENDENCY
    "find_dependency(CUDAToolkit ${CUDAToolkit_VERSION})")
  if (CMAKE_VERSION VERSION_GREATER_EQUAL "3.18")
    # Support Maxwell, Pascal, Volta, Turing, and Ampere GPUs.
    set(CMAKE_CUDA_ARCHITECTURES "50;60;70;80")
    message(STATUS "Setting CUDA Architecture to ${CMAKE_CUDA_ARCHITECTURES}")
  endif()
  list(APPEND CERES_CUDA_LIBRARIES
    CUDA::cublas
    CUDA::cudart
    CUDA::cusolver
    CUDA::cusparse)
  set(CMAKE_CUDA_RUNTIME_LIBRARY NONE)
endif (CUDA_FOUND)

if (NOT CMAKE_CUDA_COMPILER OR NOT ${CUDAPackage}_FOUND)
  list (APPEND CERES_COMPILE_OPTIONS CERES_NO_CUDA)
endif (NOT CMAKE_CUDA_COMPILER OR NOT ${CUDAPackage}_FOUND)

# Set the install path for the installed CeresConfig.cmake configuration file
# relative to CMAKE_INSTALL_PREFIX.
set(RELATIVE_CMAKECONFIG_INSTALL_DIR ${CMAKE_INSTALL_LIBDIR}/cmake/Ceres)

if (SuiteSparse_FOUND)
  # By default, if SuiteSparse and all dependencies are found, Ceres is
  # built with SuiteSparse support.

  # Check for SuiteSparse and dependencies.
  set(SuiteSparse_DEPENDENCY "find_dependency(SuiteSparse ${SuiteSparse_VERSION})")
  # By default, if all of SuiteSparse's dependencies are found, Ceres is
  # built with SuiteSparse support.
  if (SuiteSparse_NO_CMAKE OR NOT SuiteSparse_DIR)
    install(FILES ${Ceres_SOURCE_DIR}/cmake/FindSuiteSparse.cmake
                  ${Ceres_SOURCE_DIR}/cmake/FindMETIS.cmake
            DESTINATION ${RELATIVE_CMAKECONFIG_INSTALL_DIR})
  endif (SuiteSparse_NO_CMAKE OR NOT SuiteSparse_DIR)
else (SuiteSparse_FOUND)
  list(APPEND CERES_COMPILE_OPTIONS CERES_NO_SUITESPARSE)
endif (SuiteSparse_FOUND)

if (NOT SuiteSparse_Partition_FOUND)
  list (APPEND CERES_COMPILE_OPTIONS CERES_NO_CHOLMOD_PARTITION)
endif (NOT SuiteSparse_Partition_FOUND)

if (METIS_FOUND)
  # Since METIS is a private dependency of Ceres, it requires access to the
  # link-only METIS::METIS target to avoid undefined linker errors in projects
  # relying on Ceres. We do not actually need to propagate anything besides
  # the link libraries (such as include directories.)
  set(METIS_DEPENDENCY "find_dependency(METIS ${METIS_VERSION})")
  # METIS find module must be installed unless a package config is being used.
  if (NOT METIS_DIR)
    install(FILES ${Ceres_SOURCE_DIR}/cmake/FindMETIS.cmake
            DESTINATION ${RELATIVE_CMAKECONFIG_INSTALL_DIR})
  endif (NOT METIS_DIR)
else (METIS_FOUND)
  list (APPEND CERES_COMPILE_OPTIONS CERES_NO_EIGEN_METIS)
endif (METIS_FOUND)

if (NOT AccelerateSparse_FOUND)
  list (APPEND CERES_COMPILE_OPTIONS CERES_NO_ACCELERATE_SPARSE)
endif (NOT AccelerateSparse_FOUND)

# Ensure that the user understands they have disabled all sparse libraries.
if (NOT SuiteSparse_FOUND AND NOT WITH_EIGENSPARSE AND NOT AccelerateSparse_FOUND)
  message("   ===============================================================")
  message("   Compiling without any sparse library: SuiteSparse, ")
  message("   EigenSparse & Apple's Accelerate are all disabled or unavailable.  ")
  message("   No sparse linear solvers (SPARSE_NORMAL_CHOLESKY & SPARSE_SCHUR)")
  message("   will be available when Ceres is used.")
  message("   ===============================================================")
endif()

# ANDROID define is set by the Android CMake toolchain file.
if (ANDROID)
  message("  ================================================================")
  if (WITH_STRIPPED_DEBUG_SYMBOLS)
    # Strip debug information unconditionally to avoid +200MB library file sizes.
    set( CMAKE_EXE_LINKER_FLAGS  "${CMAKE_EXE_LINKER_FLAGS} -s" )
    set( CMAKE_SHARED_LINKER_FLAGS  "${CMAKE_SHARED_LINKER_FLAGS} -s" )
    message("  Stripping debug information from Android build of Ceres library ")
    message("  to avoid +200MB library files.")
  else()
    message("  Warning: not stripping debug information from Android build of ")
    message("  Ceres library.  This will result in a large (+200MB) library.")
  endif()
  message("")
  message("  You can control whether debug information is stripped via the ")
  message("  WITH_STRIPPED_DEBUG_SYMBOLS CMake option when configuring Ceres.")
  message("  ================================================================")
endif()

# MiniGLog.
if (WITH_MINIGLOG)
  set(GLOG_INCLUDE_DIRS internal/ceres/miniglog)
  set(MINIGLOG_MAX_LOG_LEVEL 2 CACHE STRING "The maximum message severity level to be logged")
  add_definitions("-DMAX_LOG_LEVEL=${MINIGLOG_MAX_LOG_LEVEL}")
  message(STATUS "Max log level for minimal glog substitute: ${MINIGLOG_MAX_LOG_LEVEL}")

  # Mark as advanced (remove from default GUI view) the glog search
  # variables in case user disables WITH_MINIGLOG, FindGlog did not find it, so
  # made search variables visible in GUI for user to set, but then user enables
  # WITH_MINIGLOG instead of setting them.
  mark_as_advanced(FORCE GLOG_INCLUDE_DIR
                         GLOG_LIBRARY)
else (WITH_MINIGLOG)
  unset(MINIGLOG_MAX_LOG_LEVEL CACHE)
  # Don't search with REQUIRED so that configuration continues if not found and
  # we can output an error messages explaining WITH_MINIGLOG option.
  if (NOT GLOG_FOUND)
    message(FATAL_ERROR "Can't find Google Log (glog). Please set either: "
      "glog_DIR (newer CMake built versions of glog) or GLOG_INCLUDE_DIR & "
      "GLOG_LIBRARY or enable WITH_MINIGLOG option to use minimal glog "
      "implementation.")
  endif(NOT GLOG_FOUND)
  # By default, assume gflags was found, updating the message if it was not.
  set(GLOG_GFLAGS_DEPENDENCY_MESSAGE
    " Assuming glog was built with gflags support as gflags was found. "
    "This will make gflags a public dependency of Ceres.")
  if (NOT gflags_FOUND)
    set(GLOG_GFLAGS_DEPENDENCY_MESSAGE
      " Assuming glog was NOT built with gflags support as gflags was "
      "not found.  If glog was built with gflags, please set the "
      "gflags search locations such that it can be found by Ceres.  "
      "Otherwise, Ceres may fail to link due to missing gflags symbols.")
  endif(NOT gflags_FOUND)
  message(STATUS "Found Google Log (glog)." ${GLOG_GFLAGS_DEPENDENCY_MESSAGE})
endif (WITH_MINIGLOG)

if (NOT WITH_SCHUR_SPECIALIZATIONS)
  list(APPEND CERES_COMPILE_OPTIONS CERES_RESTRICT_SCHUR_SPECIALIZATION)
endif (NOT WITH_SCHUR_SPECIALIZATIONS)

if (NOT WITH_CUSTOM_BLAS)
  list(APPEND CERES_COMPILE_OPTIONS CERES_NO_CUSTOM_BLAS)
endif (NOT WITH_CUSTOM_BLAS)

# Change the default build type from Debug to Release, while still
# supporting overriding the build type.
#
# The CACHE STRING logic here and elsewhere is needed to force CMake
# to pay attention to the value of these variables.
if (NOT CMAKE_BUILD_TYPE)
  message(STATUS "No build type specified; defaulting to CMAKE_BUILD_TYPE=Release.")
  set(CMAKE_BUILD_TYPE Release CACHE STRING
    "Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel."
    FORCE)
else (NOT CMAKE_BUILD_TYPE)
  if (CMAKE_BUILD_TYPE STREQUAL "Debug")
    message("\n=================================================================================")
    message("\n-- Build type: Debug. Performance will be terrible!")
    message(STATUS "Add -DCMAKE_BUILD_TYPE=Release to the CMake command line to get an optimized build.")
    message("\n=================================================================================")
  endif (CMAKE_BUILD_TYPE STREQUAL "Debug")
endif (NOT CMAKE_BUILD_TYPE)

if (MINGW)
  # MinGW produces code that segfaults when performing matrix multiplications
  # in Eigen when compiled with -O3 (see [1]), as such force the use of -O2
  # which works.
  #
  # [1] http://eigen.tuxfamily.org/bz/show_bug.cgi?id=556
  message(STATUS "MinGW detected, forcing -O2 instead of -O3 in Release for Eigen due "
          "to a MinGW bug: http://eigen.tuxfamily.org/bz/show_bug.cgi?id=556")
  string(REPLACE "-O3" "-O2" CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}")
  update_cache_variable(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}")
endif (MINGW)

# After the tweaks for the compile settings, disable some warnings on MSVC.
if (MSVC)
  # Insecure standard library functions
  add_compile_definitions(_CRT_SECURE_NO_WARNINGS)
  # std::numeric_limits<T>::has_denorm is deprecated in C++23
  add_compile_definitions($<$<COMPILE_LANGUAGE:CXX>:_SILENCE_CXX23_DENORM_DEPRECATION_WARNING>)
  # std::aligned_storage is deprecated in C++23
  add_compile_definitions($<$<COMPILE_LANGUAGE:CXX>:_SILENCE_CXX23_ALIGNED_STORAGE_DEPRECATION_WARNING>)
  # Disable signed/unsigned int conversion warnings.
  add_compile_options($<$<COMPILE_LANGUAGE:CXX>:/wd4018>)
  add_compile_options($<$<COMPILE_LANGUAGE:CXX>:/wd4267>)
  # Disable warning about using struct/class for the same symbol.
  add_compile_options($<$<COMPILE_LANGUAGE:CXX>:/wd4099>)
  # Disable performance warning about int-to-bool conversion.
  add_compile_options($<$<COMPILE_LANGUAGE:CXX>:/wd4800>)
  # Disable warning about int64 to int32 conversion. Disabling
  # this warning may not be correct; needs investigation.
  # TODO(keir): Investigate these warnings in more detail.
  add_compile_options($<$<COMPILE_LANGUAGE:CXX>:/wd4244>)
  # It's not possible to use STL types in DLL interfaces in a portable and
  # reliable way. However, that's what happens with Google Log and Google Flags
  # on Windows. MSVC gets upset about this and throws warnings that we can't do
  # much about. The real solution is to link static versions of Google Log and
  # Google Test, but that seems tricky on Windows. So, disable the warning.
  add_compile_options($<$<COMPILE_LANGUAGE:CXX>:/wd4251>)

  # Add bigobj flag otherwise the build would fail due to large object files
  # probably resulting from generated headers (like the fixed-size schur
  # specializations).
  add_compile_options($<$<COMPILE_LANGUAGE:CXX>:/bigobj>)

  # Google Flags doesn't have their DLL import/export stuff set up correctly,
  # which results in linker warnings. This is irrelevant for Ceres, so ignore
  # the warnings.
  set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /ignore:4049")

  # Tuple sizes of 10 are used by Gtest.
  add_definitions("-D_VARIADIC_MAX=10")
endif (MSVC)

if (UNIX)
  # Flags which we add to GCC to make it more picky about stuff
  # we do care about,
  add_cxx_compiler_flag_if_supported(CERES_STRICT_CXX_FLAGS
                                     -Wmissing-declarations)
  # Flags which we add to GCC to silence lots of annoying false-positives.
  add_cxx_compiler_flag_if_supported(CERES_STRICT_CXX_FLAGS
                                     -Wno-unknown-pragmas)
  add_cxx_compiler_flag_if_supported(CERES_STRICT_CXX_FLAGS
                                     -Wno-sign-compare)
  add_cxx_compiler_flag_if_supported(CERES_STRICT_CXX_FLAGS
                                     -Wno-unused-parameter)
  add_cxx_compiler_flag_if_supported(CERES_STRICT_CXX_FLAGS
                                     -Wno-missing-field-initializers)
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CERES_STRICT_CXX_FLAGS}")
endif (UNIX)

if (CMAKE_CXX_COMPILER_ID MATCHES "Clang") # Matches Clang & AppleClang.
  # Optimize for Eigen OR enable bitcode; you cannot do both since bitcode is an
  # intermediate representation.
  if (WITH_BITCODE)
    set(CMAKE_CXX_FLAGS
      "${CMAKE_CXX_FLAGS} -fembed-bitcode")
  else ()
    # Use a larger inlining threshold for Clang, since it hobbles Eigen,
    # resulting in an unreasonably slow version of the blas routines. The
    # -Qunused-arguments is needed because CMake passes the inline
    # threshold to the linker and clang complains about it and dies.
    set(CMAKE_CXX_FLAGS
      "${CMAKE_CXX_FLAGS} -Qunused-arguments -mllvm -inline-threshold=600")
  endif ()
  # Older versions of Clang (<= 2.9) do not support the 'return-type-c-linkage'
  # option, so check for its presence before adding it to the default flags set.
  check_cxx_compiler_flag("-Wno-return-type-c-linkage"
                          HAVE_RETURN_TYPE_C_LINKAGE)
  if (HAVE_RETURN_TYPE_C_LINKAGE)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-return-type-c-linkage")
  endif(HAVE_RETURN_TYPE_C_LINKAGE)
endif ()

add_compile_definitions($<$<BOOL:${WIN32}>:NOMINMAX>)

# Configure the Ceres config.h compile options header using the current
# compile options and put the configured header into the Ceres build
# directory.  Note that the ceres/internal subdir in <build>/config where
# the configured config.h is placed is important, because Ceres will be
# built against this configured header, it needs to have the same relative
# include path as it would if it were in the source tree (or installed).
list(REMOVE_DUPLICATES CERES_COMPILE_OPTIONS)
create_ceres_config("${CERES_COMPILE_OPTIONS}"
  ${Ceres_BINARY_DIR}/${CMAKE_INSTALL_INCLUDEDIR}/ceres/internal)

add_subdirectory(internal/ceres)

if (BUILD_DOCUMENTATION)
  if (NOT Sphinx_FOUND)
    update_cache_variable(BUILD_DOCUMENTATION OFF)
  else()
    # Generate the User's Guide (html).
    # The corresponding target is ceres_docs, but is included in ALL.
    add_subdirectory(docs)
  endif()
endif (BUILD_DOCUMENTATION)

if (BUILD_EXAMPLES)
  add_subdirectory(examples)
endif (BUILD_EXAMPLES)

# Setup installation of Ceres public headers.
file(GLOB CERES_HDRS ${Ceres_SOURCE_DIR}/include/ceres/*.h)
install(FILES ${CERES_HDRS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/ceres)

file(GLOB CERES_PUBLIC_INTERNAL_HDRS ${Ceres_SOURCE_DIR}/include/ceres/internal/*.h)
install(FILES ${CERES_PUBLIC_INTERNAL_HDRS} DESTINATION
  ${CMAKE_INSTALL_INCLUDEDIR}/ceres/internal)

# Also setup installation of Ceres config.h configured with the current
# build options and export.h into the installed headers directory.
install(DIRECTORY ${Ceres_BINARY_DIR}/${CMAKE_INSTALL_INCLUDEDIR}/
        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})

if (WITH_MINIGLOG)
  # Install miniglog header if being used as logging #includes appear in
  # installed public Ceres headers.
  install(FILES ${Ceres_SOURCE_DIR}/internal/ceres/miniglog/glog/logging.h
          DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/ceres/internal/miniglog/glog)
endif (WITH_MINIGLOG)

# Ceres supports two mechanisms by which it can be detected & imported into
# client code which uses CMake via find_package(Ceres):
#
#   1) Installation (e.g. to /usr/local), using CMake's install() function.
#
#   2) (Optional) Export of the current build directory into the local CMake
#      package registry, using CMake's export() function.  This allows use of
#      Ceres from other projects without requiring installation.
#
# In both cases, we need to generate a configured CeresConfig.cmake which
# includes additional autogenerated files which in concert create an imported
# target for Ceres in a client project when find_package(Ceres) is invoked.
# The key distinctions are where this file is located, and whether client code
# references installed copies of the compiled Ceres headers/libraries,
# (option #1: installation), or the originals in the source/build directories
# (option #2: export of build directory).
#
# NOTE: If Ceres is both exported and installed, provided that the installation
#       path is present in CMAKE_MODULE_PATH when find_package(Ceres) is called,
#       the installed version is preferred.

# Build the list of Ceres components for CeresConfig.cmake from the current set
# of compile options.
ceres_compile_options_to_components("${CERES_COMPILE_OPTIONS}"
  CERES_COMPILED_COMPONENTS)


# Create a CeresConfigVersion.cmake file containing the version information,
# used by both export() & install().
write_basic_package_version_file("${Ceres_BINARY_DIR}/CeresConfigVersion.cmake"
  VERSION ${CERES_VERSION}
  COMPATIBILITY SameMajorVersion)

# Install method #1: Put Ceres in CMAKE_INSTALL_PREFIX: /usr/local or equivalent.

# This "exports" for installation all targets which have been put into the
# export set "CeresExport". This generates a CeresTargets.cmake file which,
# when read in by a client project as part of find_package(Ceres) creates
# imported library targets for Ceres (with dependency relations) which can be
# used in target_link_libraries() calls in the client project to use Ceres.
install(EXPORT CeresExport
        NAMESPACE Ceres::
        DESTINATION ${RELATIVE_CMAKECONFIG_INSTALL_DIR} FILE CeresTargets.cmake)

# Save the relative path from the installed CeresConfig.cmake file to the
# install prefix.  We do not save an absolute path in case the installed package
# is subsequently relocated after installation (on Windows).
file(RELATIVE_PATH INSTALL_ROOT_REL_CONFIG_INSTALL_DIR
     ${CMAKE_INSTALL_PREFIX}/${RELATIVE_CMAKECONFIG_INSTALL_DIR}
     ${CMAKE_INSTALL_PREFIX})

# Configure a CeresConfig.cmake file for an installed version of Ceres from the
# template, reflecting the current build options.
#
# NOTE: The -install suffix is necessary to distinguish the install version from
#       the exported version, which must be named CeresConfig.cmake in
#       Ceres_BINARY_DIR to be detected.  The suffix is removed when
#       it is installed.
set(SETUP_CERES_CONFIG_FOR_INSTALLATION TRUE)
configure_file("${Ceres_SOURCE_DIR}/cmake/CeresConfig.cmake.in"
               "${Ceres_BINARY_DIR}/CeresConfig-install.cmake" @ONLY)

# Install the configuration files into the same directory as the autogenerated
# CeresTargets.cmake file.  We include the find_package() scripts for libraries
# whose headers are included in the public API of Ceres and should thus be
# present in CERES_INCLUDE_DIRS.
install(FILES "${Ceres_BINARY_DIR}/CeresConfig-install.cmake"
        RENAME CeresConfig.cmake
        DESTINATION ${RELATIVE_CMAKECONFIG_INSTALL_DIR})
install(FILES "${Ceres_BINARY_DIR}/CeresConfigVersion.cmake"
        DESTINATION ${RELATIVE_CMAKECONFIG_INSTALL_DIR})
if (GLOG_FOUND AND NOT FOUND_INSTALLED_GLOG_CMAKE_CONFIGURATION)
  # Version of glog detected was not built with CMake, install our glog module
  # file to enable detection in CeresConfig.
  install(FILES "${Ceres_SOURCE_DIR}/cmake/FindGlog.cmake"
          DESTINATION ${RELATIVE_CMAKECONFIG_INSTALL_DIR})
endif()

if (WITH_UNINSTALL_TARGET)
  # Create an uninstall target to remove all installed files.
  configure_file("${Ceres_SOURCE_DIR}/cmake/uninstall.cmake.in"
                 "${Ceres_BINARY_DIR}/cmake/uninstall.cmake"
                 @ONLY)
  add_custom_target(uninstall
                    COMMAND ${CMAKE_COMMAND} -P ${Ceres_BINARY_DIR}/cmake/uninstall.cmake)
endif()

# Install method #2: Put Ceres build into local CMake registry.
#
# Optionally export the Ceres build directory into the local CMake package
# registry (~/.cmake/packages on *nix & OS X).  This allows the detection &
# use of Ceres without requiring that it be installed.

# Save the relative path from the build directory to the source directory.
file(RELATIVE_PATH INSTALL_ROOT_REL_CONFIG_INSTALL_DIR
  ${Ceres_BINARY_DIR}
  ${Ceres_SOURCE_DIR})

set (Ceres_EXPORT_TARGETS ceres)

if (TARGET ceres_cuda_kernels)
  # The target ceres depends on ceres_cuda_kernels requiring the latter to be
  # exported as part of the same export set.
  list (APPEND Ceres_EXPORT_TARGETS ceres_cuda_kernels)
endif (TARGET ceres_cuda_kernels)

# Analogously to install(EXPORT ...), export the Ceres target from the build
# directory as a package called Ceres into the local CMake package registry.
export(TARGETS ${Ceres_EXPORT_TARGETS}
       NAMESPACE Ceres::
       FILE ${Ceres_BINARY_DIR}/CeresTargets.cmake)
export(PACKAGE ${CMAKE_PROJECT_NAME})

unset (Ceres_EXPORT_TARGETS)

if (NOT CMAKE_EXPORT_NO_PACKAGE_REGISTRY)
  # Configure a CeresConfig.cmake file for the export of the Ceres build
  # directory from the template, reflecting the current build options.
  set(SETUP_CERES_CONFIG_FOR_INSTALLATION FALSE)
  configure_file("${Ceres_SOURCE_DIR}/cmake/CeresConfig.cmake.in"
    "${Ceres_BINARY_DIR}/CeresConfig.cmake" @ONLY)
endif (NOT CMAKE_EXPORT_NO_PACKAGE_REGISTRY)

add_feature_info ("Apple Accelerate Sparse" WITH_ACCELERATESPARSE "Support for sparse solvers in Apple's Accelerate framework")
add_feature_info ("CUDA Acceleration" WITH_CUDA "NVIDIA速 CUDA速 accelerated solvers")
add_feature_info ("Custom BLAS" WITH_CUSTOM_BLAS "Use of a custom BLAS implementation")
add_feature_info (Documentation BUILD_DOCUMENTATION
  "Ceres HTML documentation built using Sphinx documentation generator")
add_feature_info ("Eigen METIS" WITH_EIGENMETIS "Eigen METIS support")
add_feature_info ("Eigen Sparse" WITH_EIGENSPARSE
"Eigen sparse linear algebra library support. \
This does not affect the covariance estimation algorithm which can still use the EIGEN_SPARSE_QR algorithm.")
add_feature_info (Examples BUILD_EXAMPLES "Ceres usage examples")
add_feature_info ("Mini glog" WITH_MINIGLOG "Stripped down version of glog")
add_feature_info ("Shared library" BUILD_SHARED_LIBS "Build Ceres as a shared library")
add_feature_info ("Schur specializations" WITH_SCHUR_SPECIALIZATIONS "Fixed-size Schur specializations")
add_feature_info (Tests BUILD_TESTING "Ceres unit testing")

set_package_properties (AccelerateSparse PROPERTIES
  DESCRIPTION "Apple's Accelerate framework with sparse solvers"
)

set_package_properties (benchmark PROPERTIES
  DESCRIPTION "A microbenchmark support library"
  URL "https://github.com/google/benchmark"
  PURPOSE "Bechmarking of core library"
)

set_package_properties (BLAS PROPERTIES
  DESCRIPTION "Basic Linear Algebra Subprograms"
  PURPOSE "LAPACK dependency"
)

set_package_properties (${CUDAPackage} PROPERTIES
  DESCRIPTION "High performance GPU-acceleration"
  URL "https://developer.nvidia.com/cuda-toolkit"
  PURPOSE "Solver acceleration using NVIDIA速 CUDA速"
)

set_package_properties (Glog PROPERTIES
  DESCRIPTION "C++ implementation of the Google logging module"
  TYPE RECOMMENDED
  URL "https://github.com/google/glog"
  PURPOSE "Logging support"
)

set_package_properties (gflags PROPERTIES
  DESCRIPTION "C++ library from commandline flags processing"
  URL "https://github.com/gflags/gflags"
  PURPOSE "glog dependecy, and testing and tools support"
)

set_package_properties (Eigen3 PROPERTIES
  DESCRIPTION "C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms"
  URL "http://eigen.tuxfamily.org"
)

set_package_properties (LAPACK PROPERTIES
  DESCRIPTION "Linear Algebra PACKage"
  TYPE RECOMMENDED
)

set_package_properties (METIS PROPERTIES
  DESCRIPTION "Serial graph partitioning and fill-reducing matrix ordering"
  TYPE RECOMMENDED
)

set_package_properties (Sphinx PROPERTIES
  DESCRIPTION "Documentation generator"
  URL "https://www.sphinx-doc.org"
)

set_package_properties (SuiteSparse PROPERTIES
  DESCRIPTION "A suite of sparse matrix algorithms"
  TYPE RECOMMENDED
  URL "http://faculty.cse.tamu.edu/davis/suitesparse.html"
)

set_package_properties (TBB PROPERTIES
  DESCRIPTION "Threading Building Blocks"
  PURPOSE "SuiteSparseQR dependency"
)

set_package_properties (Threads PROPERTIES
  DESCRIPTION "Native threading implementation"
  PURPOSE "Multithreading support"
)

set_package_properties (OpenMP PROPERTIES
  DESCRIPTION "Multiprocessing API support"
  PURPOSE "Used for the implementation of the OpenMP multithreading backend"
)

feature_summary (WHAT ALL)
